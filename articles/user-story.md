# User Story
User Story – это описание функциональности с точки зрения пользователя, которая приносит ценность бизнесу. Истории помогают команде лучше понять, что нужно сделать, для кого и зачем.

User Stories являются частью Agile-подхода и помогают избежать сложных технических требований на ранних этапах, концентрируясь на бизнес-ценности.

## Форматы

Существует несколько популярных шаблонов для написания User Stories. Выбор формата зависит от специфики продукта, типа пользователей и контекста задачи.

| Название                                 | Формат                                                    | Когда применять                                           | Комментарии                                             |
|------------------------------------------|-----------------------------------------------------------|-----------------------------------------------------------|---------------------------------------------------------|
| **User Story (Connextra Template)**      | Как [роль], я хочу [функциональность], чтобы [бизнес-ценность] | Большинство историй, когда есть четкая роль пользователя | Хорошо работает в большинстве случаев, но не учитывает контекст |
| **Job Story (Jobs-to-Be-Done)**          | Когда [контекст], я хочу [действие], чтобы [ожидаемый результат] | Когда важен контекст использования и мотивация           | Лучше для продуктового подхода, чем классические US    |
| **Gherkin (Given-When-Then)**            | Given [исходное условие], When [действие], Then [ожидаемый результат] | Когда важно задать четкие критерии приемки и тестирования | Идеально для BDD и тестируемых сценариев               |
| **Техническая история (Technical Story)** | Мы должны [техническая задача], чтобы [цель]              | Когда задача не приносит прямую бизнес-ценность, но нужна для архитектуры | Важно правильно приоритизировать, иначе бизнес отложит |

## Как работать со сторями?

### INVEST

INVEST — это акроним, который помогает определить, насколько хорошо сформулирована User Story. Каждый пункт описывает важное качество истории, которое делает ее полезной для команды разработки.

**I – Independent (Независимая)**  
История должна быть самодостаточной и не зависеть от других историй, чтобы ее можно было разрабатывать и тестировать отдельно.  
- Плохо: «Добавить кнопку “Купить”, которая работает после реализации корзины».  
- Хорошо: «Пользователь может добавить товар в корзину». Корзина и покупка могут разрабатываться независимо.

**N – Negotiable (Договороспособная)**  
История не должна быть жестко зафиксированным требованием, она должна оставлять место для обсуждения деталей в команде.  
- Плохо: «Система должна отправлять email через SMTP-сервер X, а не Y».  
- Хорошо: «Пользователь должен получать подтверждение заказа по email». Детали реализации могут обсуждаться.

**V – Valuable (Ценная)**  
История должна приносить ценность пользователю или бизнесу. Если история не дает пользы, ее нет смысла разрабатывать.  
- Плохо: «Добавить таблицу в базу данных».  
- Хорошо: «Пользователь может видеть список своих заказов».

**E – Estimable (Оцениваемая)**  
История должна быть понятной, чтобы команда могла оценить ее сложность и трудозатраты.  
- Плохо: «Оптимизировать работу системы».  
- Хорошо: «Оптимизировать SQL-запросы для загрузки каталога товаров».

**S – Small (Небольшая)**  
История должна быть достаточно маленькой, чтобы ее можно было выполнить за один спринт или несколько дней. Если она слишком большая, ее нужно разделить.  
- Плохо: «Пользователь должен иметь личный кабинет с профилем, историей заказов, настройками, подписками и уведомлениями».  
- Хорошо: «Пользователь может редактировать свои персональные данные в профиле».

**T – Testable (Тестируемая)**  
История должна иметь понятные критерии приемки, по которым можно проверить, выполнена ли она.  
- Плохо: «Сайт должен работать быстро».  
- Хорошо: «Страница каталога должна загружаться не дольше 2 секунд при 1000 товарах».

Если User Story соответствует всем шести критериям INVEST, ее можно считать качественной и готовой для разработки.

### SPIDR

**SPIDR** – это метод декомпозиции User Story, который помогает разрезать крупные истории на управляемые части. Метод основан на пяти подходах:

**S – Spike (исследование)**  
Если в User Story есть неопределенность или технический риск, сначала создается исследовательская задача (Spike). Она помогает команде разобраться в проблеме перед реализацией.  
Пример: Вместо «Реализовать интеграцию с платежной системой» можно создать Spike «Исследовать API платежной системы».

**P – Path (разные сценарии использования)**  
Историю можно разделить на несколько вариантов прохождения сценария – успешный (happy path) и неуспешный (unhappy path).  
Пример: Для истории «Пользователь вводит данные карты и оплачивает заказ» можно создать отдельные истории для успешной оплаты, отказа в оплате, истекшей карты и неверного CVV.

**I – Interfaces (разделение по интерфейсам)**  
Историю можно разделить на разные уровни системы – пользовательский интерфейс (UI), API, базу данных или интеграцию с внешними сервисами.  
Пример: Для истории «Пользователь может просматривать список заказов» можно создать подзадачи: «Разработать API для получения списка заказов», «Создать UI-компонент для отображения заказов».

**D – Data (разные наборы данных)**  
Если функциональность работает с разными наборами данных, историю можно разделить по этим данным.  
Пример: Для истории «Пользователь может фильтровать товары» можно создать отдельные истории: «Фильтрация по категории», «Фильтрация по цене», «Фильтрация по наличию».

**R – Rules (разные бизнес-правила)**  
Если история содержит несколько сложных бизнес-правил, их можно разделить на отдельные истории.  
Пример: Для истории «Пользователь может зарегистрироваться» можно выделить отдельные истории: «Регистрация через email», «Регистрация через социальные сети», «Проверка на дубликаты email».

SPIDR помогает структурировать работу с крупными историями и сделать их более управляемыми. Выбор метода разбиения зависит от контекста задачи.

#### Как ставить спайки

**Правила хорошей задачи-спайка (Spike)**

Spike — это исследовательская задача, цель которой — **разобраться в неизвестности** перед реализацией функционала. В отличие от обычных задач разработки, спайки не создают напрямую пользовательскую ценность, а помогают команде лучше понять проблему.

**1. Четкая цель и гипотеза**
Спайк должен иметь четкий вопрос, на который необходимо получить ответ. Без конкретной цели спайк может превратиться в бесконечное исследование.
- Плохо: «Разобраться, как работает AI в рекомендациях»  
- Хорошо: «Исследовать, какие API предлагает OpenAI для персонализированных рекомендаций»

**2. Ограниченное время (Timebox)**
Спайки должны быть ограничены по времени. Обычно это 4–8 часов или 1–2 дня спринта. Если по истечении времени ответа нет, принимается решение о следующем шаге.  
- Плохо: «Исследуем, пока не поймем»
- Хорошо: «Выделяем 6 часов на изучение доступных библиотек и пишем отчет»

**3. Конкретный выход (Deliverable)**
Выходом спайка должен быть **конкретный артефакт**, который помогает принять решение. Это может быть документ с выводами, кодовый прототип, список возможных решений с оценкой.
- Плохо: «Мы что-то узнали»
- Хорошо: «Создан документ с анализом трех библиотек и рекомендацией по выбору»

**4. Отсутствие строгих требований к качеству кода**
Если в ходе спайка пишется код, он не должен сразу идти в продакшен. Спайк — это эксперименты, прототипирование. Окончательная реализация будет в основной задаче.
- Плохо: «Код из спайка переходит в прод»
- Хорошо: «По результатам спайка создаем новую User Story на реализацию»

**5. Минимальный охват темы**
Спайк не должен превращаться в изучение всей технологии. Он должен быть сфокусирован на конкретном вопросе.
- Плохо: «Разобраться, как работает PostgreSQL»
- Хорошо: «Определить, насколько PostgreSQL подходит для хранения JSON-данных»

**6. Четкая связь с бэклогом**
Спайк должен приводить к конкретному решению, которое влияет на план разработки. По результатам может быть создана новая User Story, изменены требования или приняты архитектурные решения.  
- Плохо: «Исследовали, но не знаем, что с этим делать»
- Хорошо: «После спайка приняли решение использовать библиотеку X, создаем задачу на интеграцию»

Если придерживаться этих правил, спайки помогут команде **избежать неопределенности**, не превращаясь в бесконечные исследования.

### USM

**User Story Mapping (USM)** – это техника управления бэклогом и планирования продукта, предложенная Джеффом Паттоном. Она помогает визуально структурировать пользовательские истории, понять путь пользователя и выделить минимально жизнеспособный продукт (MVP).

User Story Mapping строится в виде двухмерной карты. По горизонтали располагается последовательность действий пользователя, а по вертикали – детализация и приоритет задач.

Основные элементы карты:

1. **Пользовательский поток (Backbone)** – верхний уровень карты, описывающий основные этапы взаимодействия пользователя с продуктом. Например, для интернет-магазина это может быть: выбор товара, добавление в корзину, оформление заказа, оплата, получение товара.
2. **Основные задачи (Steps)** – действия, которые выполняет пользователь на каждом этапе. Например, в разделе «Выбор товара» могут быть такие задачи, как «Поиск по каталогу», «Фильтрация товаров», «Просмотр карточки товара».
3. **Детальные пользовательские истории (Details)** – конкретные истории, относящиеся к каждой задаче. Например, для «Просмотр карточки товара» могут быть истории: «Как пользователь, я хочу видеть цену товара», «Как пользователь, я хочу просматривать отзывы».
4. **Приоритизация и MVP** – сверху вниз располагаются истории по приоритету, где верхний слой – минимально необходимый для релиза функционал. Это помогает выделить MVP, а затем планировать дальнейшие итерации.

User Story Mapping полезен, когда нужно структурировать сложные фичи, увидеть зависимость между историями и создать дорожную карту продукта. Этот метод позволяет команде сфокусироваться на пользовательском опыте, а не просто на списке задач в бэклоге.

### USH

User Story Hamburger – это метод разбиения пользовательских историй, который помогает найти **оптимальный баланс между функциональностью (начинка) и окружением (тримминг)**. Главная идея метода в том, что **основная ценность истории находится в начинке, а тримминг делает ее более удобной, но не критично важной**.

#### Структура User Story Hamburger

**1. Начинка (Patty) – основная функциональность**  
Это ключевая суть истории – минимально необходимая функциональность, которая несет основную бизнес-ценность. Если оставить только этот слой, то функциональность будет работать, но без удобств.  
Пример: «Как покупатель, я хочу оформить заказ и оплатить его онлайн».

**2. Верхний тримминг (Top Trimming) – расширенные возможности**  
Этот слой делает историю более удобной и гибкой, но не является критичным для работы.  
Пример: «Добавить автозаполнение платежных данных» или «Добавить поддержку нескольких валют».

**3. Нижний тримминг (Bottom Trimming) – поддерживающие улучшения**  
Этот слой включает в себя дополнительные технические или UX-улучшения, которые не критичны, но повышают удобство.  
Пример: «Добавить анимацию подтверждения оплаты» или «Оптимизировать запросы для ускорения загрузки страницы».

#### **Как использовать метод?**
Когда User Story слишком большая, ее можно разрезать, **сначала выделяя начинку, а потом определяя тримминг**. Таким образом:
- Первым этапом реализуется основная функциональность (начинка).
- Затем в следующем спринте могут добавляться улучшения (тримминг).
- Если тримминг слишком большой, его можно вынести в отдельные User Stories.

Метод помогает избежать раздувания истории и реализовать самое важное в первую очередь, оставляя улучшения на потом.

### Three Cs

**Three Cs (Card, Conversation, Confirmation)** – это модель работы с пользовательскими историями, предложенная Роном Джеффрисом. Она помогает правильно структурировать процесс создания и реализации User Story, делая их не просто текстовыми описаниями, а частью более широкого процесса обсуждения и уточнения требований.

Первая C – **Card (Карточка)**. Пользовательская история начинается с краткой записи, которая фиксируется в системе управления задачами (Jira, Trello, Miro) или просто на бумажной карточке. Запись должна быть лаконичной и содержать основную идею, но не детализировать все нюансы. Пример: «Как покупатель, я хочу добавить товар в корзину, чтобы сохранить его перед покупкой».

Вторая C – **Conversation (Обсуждение)**. История не должна быть статичной, ее детали уточняются в ходе обсуждения между разработчиками, тестировщиками, аналитиками и заказчиками. Это живой процесс, в котором команда совместно уточняет требования, выявляет ограничения, предлагает решения. На этом этапе важно учитывать UX, бизнес-правила и технические аспекты.

Третья C – **Confirmation (Подтверждение)**. После обсуждения формируются критерии приемки, которые позволяют однозначно определить, выполнена ли история. Чаще всего критерии записываются в формате «Given-When-Then» или просто как список условий. Пример: «Товар должен отображаться в корзине после добавления», «Пользователь может удалить товар из корзины», «Общее количество товаров и сумма обновляются автоматически».

Модель Three Cs помогает сделать User Stories гибкими и адаптируемыми, исключая жестко зафиксированные требования. Важным аспектом является вовлечение всей команды в процесс обсуждения, что снижает риск недопонимания и увеличивает вероятность успешного выполнения задачи.

### Walking Skeleton

**Walking Skeleton** – это метод разработки, при котором создается минимально работоспособная версия системы, охватывающая весь жизненный цикл продукта, но с самым базовым функционалом. Термин был предложен Алистером Коберном и подразумевает, что продукт начинает «двигаться» (как скелет), даже если в нем пока нет всех деталей.

Метод применяется, когда важно получить **рабочую архитектуру** и протестировать основные процессы на ранних стадиях разработки. В отличие от MVP, который сосредоточен на бизнес-ценности, Walking Skeleton ориентирован на техническое основание продукта.

Основные принципы метода:

Минимальный охват. Реализуется только базовая функциональность, без сложных фич. Например, в интернет-магазине это может быть возможность зарегистрироваться, добавить товар в корзину и оформить заказ без интеграции с платежными системами.

Полное прохождение системы. Несмотря на минимальный функционал, Walking Skeleton включает весь жизненный цикл продукта – от пользовательского интерфейса до базы данных, API и инфраструктуры.

Быстрая обратная связь. Ранний запуск даже упрощенной системы позволяет выявить архитектурные проблемы, протестировать интеграции и сократить технические риски.

Итеративное развитие. После создания скелета продукт постепенно обрастает функциональностью, сохраняя работоспособность на каждом этапе.

Walking Skeleton особенно полезен для сложных систем, где важно сначала проверить основные механизмы работы перед масштабированием. Он снижает риски, ускоряет интеграцию и обеспечивает гибкость в разработке.

### Feature Slicing

**Feature Slicing** – это метод декомпозиции пользовательских историй, при котором функциональность делится на логические части (срезы), чтобы упростить разработку и постепенное внедрение фичи.

Метод используется, когда фича слишком большая для реализации в одном спринте, но ее нельзя просто разбить на технические задачи (например, фронтенд, бэкенд и API), так как это не приносит бизнес-ценности на каждом этапе.

#### **Способы нарезки фичи**

- **По сценариям использования**  
  Функциональность разделяется на разные сценарии, которые пользователь может выполнять.  
  *Пример:* если фича — авторизация, можно сначала реализовать вход по email и паролю, затем вход через соцсети и позже — двухфакторную аутентификацию.

- **По шагам процесса**  
  Разделение происходит по последовательности действий пользователя.  
  *Пример:* в процессе оформления заказа сначала разрабатывается выбор товаров, затем оформление доставки, после этого — оплата.

- **По уровням сложности**  
  Вначале реализуется базовый функционал, затем добавляются более сложные элементы.  
  *Пример:* сначала создается простой поиск товаров, затем — фильтры, потом — рекомендации.

- **По ролям пользователей**  
  Если фича затрагивает разных пользователей, ее можно разделить по ролям.  
  *Пример:* в системе управления заказами сначала реализуется интерфейс для покупателей, затем — для менеджеров, затем — для курьеров.

- **По типам данных**  
  Если фича работает с разными видами информации, можно разделить ее на этапы.  
  *Пример:* в профиле пользователя сначала реализуется редактирование имени и email, затем — загрузка аватара, позже — настройка предпочтений.

Feature Slicing помогает организовать разработку так, чтобы каждая часть приносила пользу пользователям и могла быть протестирована и внедрена независимо. Это снижает риски, ускоряет поставку ценности и делает процесс гибче.

### Workflow Steps

**Workflow Steps** – это метод декомпозиции пользовательских историй, при котором функциональность разбивается на логические шаги процесса. Этот подход особенно полезен, когда система работает по четкому сценарию, включающему несколько этапов.

#### **Принципы нарезки по шагам процесса**

- **Разбиение по естественному пользовательскому потоку**  
  История делится на этапы, которые пользователь проходит в процессе выполнения задачи.  
  *Пример:* если фича — оформление заказа, ее можно разбить на шаги:
    1. Выбор товаров.
    2. Добавление в корзину.
    3. Выбор способа доставки.
    4. Оплата.
    5. Получение подтверждения.

- **Выделение ключевых этапов, которые можно реализовать отдельно**  
  Каждый шаг должен приносить ценность сам по себе и быть независимым от последующих.  
  *Пример:* сначала можно реализовать функционал добавления в корзину, а затем выбрать способы доставки.

- **Постепенное наращивание функциональности**  
  Вначале можно запустить базовую версию каждого шага, а затем расширять его.  
  *Пример:* вначале добавить один способ оплаты (карта), а позже добавить PayPal, Google Pay и другие.

- **Разделение по ролям пользователей**  
  Если в процессе участвуют разные роли, можно декомпозировать фичу с учетом их действий.  
  *Пример:* в системе бронирования отелей можно разделить процесс на шаги для гостя (поиск, бронирование, оплата) и для администратора (подтверждение брони, управление заказами).

- **Выделение альтернативных сценариев**  
  Если процесс может идти разными путями, можно выделить их как отдельные истории.  
  *Пример:* при оформлении заказа могут быть истории для авторизованных пользователей и для гостей.

Метод Workflow Steps помогает сделать процесс внедрения новой функциональности более управляемым, снизить сложность разработки и обеспечить логическое разбиение задач для команды.